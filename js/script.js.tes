let animation;

/**
 * アプリケーションの初期化関数。ページのロード時に実行され、イベントリスナーや必要な設定を行います。
 */
function init() {
  setupCanvas();  // キャンバスの初期設定を行う
  window.addEventListener('resize', setupCanvas);  // ウィンドウのリサイズ時にキャンバスを再設定
  window.addEventListener('scroll', updateCanvasPosition);  // スクロール時にキャンバスの位置を更新
  window.addEventListener('scroll', updateContentOpacity);  // スクロール時にコンテンツの透明度を更新
  window.addEventListener('scroll', updateOpacity);  // スクロール時に透明度を更新
  observeFadeInElements();  // フェードイン要素の監視を開始
  addEventListeners();  // その他のイベントリスナーを追加
}

/**
 * キャンバスの設定を行い、波のアニメーションを初期化します。
 */
function setupCanvas() {
  const canvas = document.getElementById("waveCanvas");
  canvas.width = document.documentElement.clientWidth * 1.3;  // キャンバスの幅を設定
  canvas.height = document.documentElement.clientWidth < 768 ? 150 : 200;  // キャンバスの高さを設定
  canvas.contextCache = canvas.getContext("2d");  // 描画コンテキストをキャッシュ

  const info = { t: 0, unit: 200, amplitude: 0.3, frequency: 0.002, phase: 0 };  // 波のパラメータ
  if (animation) {
    animation.kill(); // 既存のアニメーションがあれば停止
  }
  animation = gsap.to(info, {
    duration: 1000, repeat: -1, ease: "none", phase: "+=360",
    onUpdate: () => draw(canvas, info)  // アニメーションの更新時に波を描画
  });
}

/**
 * キャンバス上に波を描画します。
 */
function draw(canvas, info) {
  const context = canvas.contextCache;
  context.clearRect(0, 0, canvas.width, canvas.height);  // キャンバスをクリア
  let gradient = context.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, 'rgba(221,255,245, 1)');  // グラデーションを設定
  context.fillStyle = gradient;
  context.beginPath();
  drawSine(canvas, info);  // サイン波を描画
  context.lineTo(canvas.width, canvas.height);
  context.lineTo(0, canvas.height);
  context.closePath();
  context.fill();  // 塗りつぶしで描画
}

/**
 * サイン波を計算し、キャンバスにラインとして描画します。
 */
function drawSine(canvas, info) {
  const context = canvas.contextCache;
  const xAxis = Math.floor(canvas.height / 2);
  context.moveTo(-10, xAxis);  // 開始点を設定
  for (let i = -10; i <= canvas.width + 10; i += 10) {
    const x = (info.t + i) * info.frequency + info.phase;
    const y = Math.sin(x) * info.amplitude * info.unit;  // y座標を計算
    context.lineTo(i, y + xAxis);  // 線を描画
  }
}

/**
 * ユーザーのスクロール位置に基づき、ヒーローセクションの位置を固定または相対に設定します。
 */
function updateCanvasPosition() {
  const scrollY = window.scrollY;
  const heroSection = document.querySelector('.hero-section');
  heroSection.style.position = scrollY > heroSection.offsetHeight ? 'fixed' : 'relative';  // 位置を固定または相対に設定
  heroSection.style.top = scrollY > heroSection.offsetHeight ? `-${heroSection.offsetHeight}px` : '0px';  // 位置を調整
}

/**
 * スクロール位置に応じてコンテンツの透明度を更新します。
 */
function updateContentOpacity() {
  const scrollY = window.scrollY;
  const opacity = 1 - Math.min(1, (scrollY - 2) / (500 - 2));  // 透明度を計算
  document.querySelector('.text-contents').style.opacity = opacity;  // テキストコンテンツの透明度を設定
  document.querySelector('.img-contents').style.opacity = opacity;  // 画像コンテンツの透明度を設定
}

/**
 * スクロール位置に基づき、キャンバスと青色のキャンバスの透明度を更新します。
 */
function updateOpacity() {
  const scrollY = window.scrollY;
  const setOpacity = (triggerHeight, maxScroll) => Math.min(1, (scrollY - triggerHeight) / (maxScroll - triggerHeight));  // 透明度を計算する関数
  document.querySelector('#waveCanvas').style.opacity = setOpacity(0, 300);  // 波のキャンバスの透明度を更新
  document.querySelector('#blue-canvas').style.opacity = setOpacity(0, 300);  // 青色のキャンバスの透明度を更新
  animation[scrollY <= 0 ? 'resume' : 'pause']();  // アニメーションを再開または一時停止
}

/**
 * フェードイン効果を監視する要素を設定します。
 */
function observeFadeInElements() {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        entry.target.classList.add("fd-in");  // フェードイン効果を適用
        observer.unobserve(entry.target);  // 監視を停止
      }
    });
  });
  document.querySelectorAll(".fd").forEach(element => observer.observe(element));  // 監視対象の要素を設定
}

/**
 * その他のイベントリスナーを追加する関数です。
 */
function addEventListeners() {
  // ハンバーガーメニューのトグル設定
  document.querySelector('.navbar-toggler').addEventListener('click', function() {
    this.classList.toggle('toggled');
  });

/**
 * コラプスセクションのアイコン切り替えを設定します。
 */
// What is …のトグル(+)->(×)へ
document.addEventListener('DOMContentLoaded', function () {
  // clrtp-collapseの設定
  const clrtpCollapseElement = document.getElementById('clrtp-collapse');
  const clrtpToggleIcon = document.querySelector('a[href="#clrtp-collapse"] .wht-pls img');

  clrtpCollapseElement.addEventListener('show.bs.collapse', function () {
    clrtpToggleIcon.src = './img/cross.webp';
    clrtpToggleIcon.alt = 'Close';
  });

  clrtpCollapseElement.addEventListener('hide.bs.collapse', function () {
    clrtpToggleIcon.src = './img/plus.webp';
    clrtpToggleIcon.alt = 'Open';
  });

  // cns-collapseの設定
  const cnsCollapseElement = document.getElementById('cns-collapse');
  const cnsToggleIcon = document.querySelector('a[href="#cns-collapse"] .wht-pls img');

  cnsCollapseElement.addEventListener('show.bs.collapse', function () {
    cnsToggleIcon.src = './img/cross.webp';
    cnsToggleIcon.alt = 'Close';
  });

  cnsCollapseElement.addEventListener('hide.bs.collapse', function () {
    cnsToggleIcon.src = './img/plus.webp';
    cnsToggleIcon.alt = 'Open';
  });
});

document.addEventListener('DOMContentLoaded', () => {
  setupCollapseIconChanges(); // コラプスアイコンの設定を追加
});


  document.addEventListener('DOMContentLoaded', () => {
    const heroSection = document.querySelector('.hero-section');
    const footerButton = document.querySelector('.fixed-bottom');
    const checkHeroSectionPosition = () => footerButton.style.opacity = window.scrollY > heroSection.getBoundingClientRect().bottom ? 1 : 0;
    window.addEventListener('scroll', checkHeroSectionPosition);
    window.addEventListener('resize', checkHeroSectionPosition);
    checkHeroSectionPosition();
  });

  document.addEventListener('DOMContentLoaded', () => {
    const footer = document.querySelector('.footer');
    const fixedBottom = document.querySelector('.container-fluid.fixed-bottom');
    const adjustPadding = () => {
      const footerRect = footer.getBoundingClientRect();
      fixedBottom.style.paddingBottom = footerRect.top < window.innerHeight ? `${footer.offsetHeight}px` : '0px';
    };
    window.addEventListener('scroll', adjustPadding);
    window.addEventListener('resize', adjustPadding);
    adjustPadding();
  });
}

init();  // 初期化関数を呼び出し
